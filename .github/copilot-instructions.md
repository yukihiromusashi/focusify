# GitHub Copilot Custom Instructions for Focusify

> **Project:** Focusify - Hybrid Pomodoro Timer Application (Wails Desktop + Fiber Web)  
> **Tech Stack:** Go (Fiber v3), Wails v3, HTMX, Alpine.js, Tailwind CSS

## Core Principles

1. **Always Use Makefile Commands** - Never run raw `go run`, `npm`, or build commands directly
2. **Hybrid Architecture** - Single codebase runs as both desktop app (Wails) and web server (Fiber)
3. **Server-Side Rendering** - Use HTMX for dynamic interactions, not JSON APIs
4. **Mode-Aware** - Desktop mode = no auth, single user; Web mode = multi-user with sessions

## Project Structure

```
focusify/
├── cmd/
│   ├── server/main.go     # Web server entry point (Fiber)
│   └── desktop/main.go    # Desktop app entry point (Wails)
├── internal/
│   ├── config/            # Configuration (mode detection)
│   ├── handlers/          # HTTP handlers (shared between modes)
│   ├── middleware/        # Middleware (mode-aware auth)
│   └── templates/         # HTML templates + embedded static files
│       ├── layouts/       # Base HTML layouts
│       ├── pages/         # Full page templates
│       ├── partials/      # HTMX partial templates
│       └── static/        # CSS, JS (generated by Tailwind)
├── frontend/              # Tailwind CSS build tooling
│   ├── src/input.css      # Tailwind source
│   └── tailwind.config.js
├── Makefile              # **USE THIS FOR ALL COMMANDS**
└── .air.toml             # Hot-reload configuration
```

## Essential Commands (Always Use These)

### Development
```bash
make deps         # Install all dependencies (Go, npm, Air, Wails)
make build-css    # Build Tailwind CSS once
make watch-css    # Watch CSS for changes (run in separate terminal)
make dev-server   # Run web server with hot-reload (Air)
make dev-desktop  # Run desktop app
```

### Production
```bash
make build-server   # Build web server binary
make build-desktop  # Build desktop app binary
make clean          # Remove build artifacts
```

## Code Patterns

### Adding a New Page
1. Create template: `internal/templates/pages/newpage.html`
2. Create handler: `internal/handlers/newpage.go`
3. Add route to **BOTH** entry points:
   - `cmd/server/main.go`
   - `cmd/desktop/main.go`
4. Always use: `c.Render("pages/newpage", data, "layouts/base")`

### Handler Pattern
```go
package handlers

import "github.com/gofiber/fiber/v3"

type MyHandler struct{}

func NewMyHandler() *MyHandler {
    return &MyHandler{}
}

func (h *MyHandler) Index(c fiber.Ctx) error {
    return c.Render("pages/mypage", fiber.Map{
        "Title":        "Page Title",
        "IsDesktopApp": c.Locals("isDesktopApp"),
        // Add your data here
    }, "layouts/base")
}
```

### Template Pattern
```html
{{define "content"}}
<div class="min-h-screen bg-gray-200 flex items-center justify-center">
    <!-- Your content here -->
    
    {{if .IsDesktopApp}}
        <p>Desktop-only UI elements</p>
    {{else}}
        <a href="/login">Web-only login</a>
    {{end}}
</div>
{{end}}
```

### HTMX Dynamic Content
1. Create partial: `internal/templates/partials/mypartial.html`
2. Add endpoint: `app.Post("/api/action", handler.Action)`
3. Render partial: `return c.Render("partials/mypartial", data)`
4. Use in HTML:
```html
<button hx-post="/api/action" hx-target="#result" hx-swap="innerHTML">
    Click Me
</button>
<div id="result"></div>
```

### Alpine.js for Client State
```html
<div x-data="{ count: 0 }">
    <button @click="count++">Increment</button>
    <p x-text="count"></p>
</div>
```

## CSS/Styling

- **Always rebuild CSS after template changes**: `make build-css`
- **For active development**: Run `make watch-css` in separate terminal
- Use Tailwind utility classes: `bg-blue-600 hover:bg-blue-700 text-white rounded`
- Custom components in `frontend/src/input.css` using `@apply`

## Important Rules

### DO
- ✅ Use `make dev-server` or `make dev-desktop` to run the app
- ✅ Use `make build-css` after modifying templates (unless using watch-css)
- ✅ Keep handlers shared between desktop and web modes
- ✅ Use HTMX for dynamic interactions (server-rendered HTML)
- ✅ Use Alpine.js for lightweight client-side state
- ✅ Add routes to **both** `cmd/server/main.go` and `cmd/desktop/main.go`
- ✅ Use `c.Locals("isDesktopApp")` to check mode in handlers
- ✅ Embed templates via `//go:embed` (already in renderer.go)

### DON'T
- ❌ Don't run `go run cmd/server/main.go` directly (use `make dev-server`)
- ❌ Don't run `npm` commands directly (use `make` targets)
- ❌ Don't create JSON REST APIs (use HTMX + server-rendered HTML)
- ❌ Don't use heavy JavaScript frameworks (we use HTMX + Alpine.js)
- ❌ Don't forget to rebuild CSS after template changes
- ❌ Don't add routes to only one entry point (update both)
- ❌ Don't bypass the Makefile for any build/run commands

## Mode-Aware Development

### Desktop Mode
- No authentication required
- Uses default user ID (from middleware)
- Embedded Fiber server on localhost
- Single-user experience

### Web Server Mode
- Session-based authentication (if implemented)
- Multi-user support
- Deployed as standalone web server
- Accessible over network

### Checking Mode in Code
```go
// In handler
isDesktop := c.Locals("isDesktopApp").(bool)
if isDesktop {
    // Desktop-specific logic
} else {
    // Web-specific logic
}
```

```html
<!-- In template -->
{{if .IsDesktopApp}}
    <p>Desktop Mode</p>
{{else}}
    <p>Web Mode</p>
{{end}}
```

## Development Workflow

### Starting Development
```bash
# Terminal 1: CSS watcher (optional but recommended)
make watch-css

# Terminal 2: Server with hot-reload
make dev-server
```

### After Making Changes
- **Go code**: Air auto-reloads (with `make dev-server`)
- **Templates**: Air auto-reloads (with `make dev-server`)
- **CSS source**: Auto-rebuilds (with `make watch-css`)
- **Desktop mode**: Manually restart (`make dev-desktop`)

## File Organization

### When to create new files:
- **Handler**: `internal/handlers/feature.go` - One handler per feature/page
- **Template**: `internal/templates/pages/feature.html` - One template per page
- **Partial**: `internal/templates/partials/component.html` - Reusable components for HTMX
- **Middleware**: `internal/middleware/feature.go` - Cross-cutting concerns

## Focusify-Specific Context

This is a **Pomodoro timer application** with:
- Timer page (focus/work sessions with clock-like interface)
- Statistics page (track completed pomodoros)
- Settings page (configure durations, preferences)

### Timer Functionality
- Start/Pause/Resume/Stop/Reset timer
- Visual circular progress indicator
- Three modes: Focusing (25min), Short Break (5min), Long Break (15min)
- Clock hand animation showing progress
- Alpine.js manages timer state and countdown

### Future Features
- Statistics tracking (completed sessions)
- Settings customization (timer durations)
- Notifications when timer completes
- Session history and analytics

## Quick Reference

| Task | Command |
|------|---------|
| Install deps | `make deps` |
| Build CSS | `make build-css` |
| Watch CSS | `make watch-css` |
| Run web server | `make dev-server` |
| Run desktop app | `make dev-desktop` |
| Build server | `make build-server` |
| Build desktop | `make build-desktop` |
| Clean build | `make clean` |
| See all commands | `make help` |

## Templates Must Use

### Base Layout
```html
{{define "content"}}
<!-- Your page content -->
{{end}}
```

### Rendering in Handler
```go
return c.Render("pages/mypage", fiber.Map{
    "Title":        "My Page",
    "IsDesktopApp": c.Locals("isDesktopApp"),
}, "layouts/base")
```

## Remember

When suggesting any command to run, debug, build, or deploy the application:
1. **Check if a Makefile target exists first**
2. **Always use `make <target>` instead of raw commands**
3. **Refer to `make help` for available commands**
4. **Update both entry points when adding routes**
5. **Rebuild CSS when templates change** (unless watch-css is running)

This ensures consistency and follows the project's established workflow.
